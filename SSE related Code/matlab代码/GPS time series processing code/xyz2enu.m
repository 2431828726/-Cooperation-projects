function [enu, covenu] = xyz2enu(llh, xyz, covxyz);%[enu, covenu] = xyz2enu(llh, xyz, covxyz)%%  Rotate coordinates from XYZ to ENU (East-North-Up).%  ENU system is defined at lat-long given by llh (degrees).%%  If a single llh is given, all vectors are transformed using that position.%  If the size of llh is the same as that of xyz, each vector is%  transformed using the corresponding position.%%  Output vector is always a column vector, regardles of input%%  covariance output argument is optional; if not given, input covariance is ignoreddeg2rad = pi/180;% Transpose the input vector if needed to make sure dimensions match for the% matrix multiplication for transformation.[row col]=size(xyz);if ( row == 1 )  xyz = xyz';end%%  Check arguments%nvec = length(xyz)/3;enu = zeros(nvec*3,1);if ( nargout == 2 )    do_covar = 1;    covenu = zeros(nvec*3,nvec*3);else    do_covar = 0;end%%  Figure out which mode of operation we should use:%   nllh == 1:  Use a single transformation for all vectors.%   nllh == nvec: Use correpsonding llh for each enu%   Otherwise: Print a warning and use single transformation%nllh = length(llh)/3;if ( nllh == nvec )    rot_at_site = 1;else    rot_at_site = 0;    if ( nllh ~= 1 )        disp('Warning: length mismatch of llh and enu; transforming using first llh value.')    end%    Calculate the transformation using first site's position    deg2rad = pi/180;    slat = sin(llh(1)*deg2rad);    clat = cos(llh(1)*deg2rad);    slon = sin(llh(2)*deg2rad);    clon = cos(llh(2)*deg2rad);    t = [ -        slon,          clon,    0;           - slat * clon, - slat * slon, clat;             clat * clon,   clat * slon, slat ];end%  Rotate XYZ vector and covariance to ENU.%  Because the transformation matrix is block-diagonal, the%  sparse matrix optimization of the transform is TCT{t}(i,j)%   = T'C(i,j)T'{t}, where T' are the diagonal block elements%  of T, and C(i,j) is the (i,j)th 3x3 block of C.for ista = 1:nvec,   k1 =  3*(ista - 1);   if ( rot_at_site == 1 )       %    Calculate the transformation using site's position       slat = sin(llh(k1+1)*deg2rad);       clat = cos(llh(k1+1)*deg2rad);       slon = sin(llh(k1+2)*deg2rad);       clon = cos(llh(k1+2)*deg2rad);        t = [ -        slon,          clon,    0;               - slat * clon, - slat * slon, clat;                 clat * clon,   clat * slon, slat ];   end   enu(k1+1:k1+3) = t*xyz(k1+1:k1+3);   if ( do_covar == 1 )%		 ... Transform each sub-block of the covariance.      for jsta = 1:nvec,      	k2 = 3*(jsta - 1);      	covenu(k1+1:k1+3,k2+1:k2+3) = t*covxyz(k1+1:k1+3,k2+1:k2+3)*t';      end   endend